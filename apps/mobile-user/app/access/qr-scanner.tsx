import AccessNotificationModal from '@/components/AccessNotificationModal';
import SessionRatingModal from '@/components/SessionRatingModal';
import { useAuth } from '@/contexts/AuthContext';
import { accessService } from '@/services/member/access.service';
import { useTheme } from '@/utils/theme';
import { Typography } from '@/utils/typography';
import { CameraView, useCameraPermissions } from 'expo-camera';
import { useRouter } from 'expo-router';
import { ArrowLeft } from 'lucide-react-native';
import React, { useEffect, useRef, useState } from 'react';
import { useTranslation } from 'react-i18next';
import {
  ActivityIndicator,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';

export default function QRScannerScreen() {
  const { t } = useTranslation();
  const { theme } = useTheme();
  const { user, member } = useAuth();
  const router = useRouter();

  const [permission, requestPermission] = useCameraPermissions();
  const [scanned, setScanned] = useState(false);
  const [processing, setProcessing] = useState(false);
  const [showRatingModal, setShowRatingModal] = useState(false);
  const [sessionData, setSessionData] = useState<any>(null);
  const [scannedQRLocation, setScannedQRLocation] =
    useState<string>('Main Entrance');

  // Notification modal state
  const [showNotification, setShowNotification] = useState(false);
  const [notificationType, setNotificationType] = useState<
    'check-in' | 'check-out' | 'error'
  >('check-in');
  const [notificationData, setNotificationData] = useState<any>(null);

  // Refs for immediate tracking (prevent race conditions)
  const isProcessingRef = useRef(false);
  const lastScanTimeRef = useRef(0);
  const lastScanDataRef = useRef('');
  const navigationTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const SCAN_COOLDOWN = 3000; // 3 seconds minimum between scans

  useEffect(() => {
    if (!permission?.granted) {
      requestPermission();
    }
  }, [permission]);

  // Reset refs when screen is focused
  useEffect(() => {
    return () => {
      // Cleanup on unmount
      isProcessingRef.current = false;
      lastScanTimeRef.current = 0;
      lastScanDataRef.current = '';
      if (navigationTimeoutRef.current) {
        clearTimeout(navigationTimeoutRef.current);
      }
    };
  }, []);

  // Auto-generate notes based on calories and body metrics
  // Notes are now generated by backend with accurate calories calculation
  // const generateSessionNotes = ... (removed, backend handles this)

  const handleRatingSubmit = async (rating: number) => {
    if (!user?.id || !sessionData) return;

    try {
      console.log('üìù Submitting rating:', rating);

      // Backend will generate accurate notes based on final calculated calories
      // Don't send notes from mobile app to avoid inconsistency

      // Perform CHECK OUT with rating (backend will generate notes)
      if (!member?.id) {
        console.error('Member ID not available');
        return;
      }
      const checkOutResponse = await accessService.checkOut({
        memberId: member.id,
        location: scannedQRLocation,
        session_rating: rating,
        // notes: undefined - let backend generate with accurate calories
        exit_method: 'QR_CODE', // Pass exit method
      });

      if (checkOutResponse.success) {
        setShowRatingModal(false);

        // Use accurate calories from backend response (calculated from equipment usage)
        const accurateCalories =
          checkOutResponse.data?.session?.calories_burned ||
          sessionData.calories;

        console.log('üî• Calories comparison:', {
          fromSession: sessionData.calories,
          fromBackend: checkOutResponse.data?.session?.calories_burned,
          usingAccurate: accurateCalories,
        });

        // Show check-out notification with accurate data
        setNotificationType('check-out');
        setNotificationData({
          location: scannedQRLocation,
          time: new Date().toLocaleTimeString(),
          duration: sessionData.duration,
          calories: accurateCalories, // ‚úÖ Use backend's accurate calories
        });
        setShowNotification(true);
        setProcessing(false);
        isProcessingRef.current = false;

        // Auto navigate to home after 3 seconds
        navigationTimeoutRef.current = setTimeout(() => {
          setShowNotification(false);
          router.push('/(tabs)');
        }, 3000);
      } else {
        setShowRatingModal(false);
        setNotificationType('error');
        setNotificationData(null);
        setShowNotification(true);
        setProcessing(false);
        isProcessingRef.current = false;

        setTimeout(() => {
          setShowNotification(false);
          setScanned(false);
        }, 2000);
      }
    } catch (error: any) {
      console.error('Rating submit error:', error);
      setShowRatingModal(false);
      setNotificationType('error');
      setNotificationData(null);
      setShowNotification(true);
      setProcessing(false);
      isProcessingRef.current = false;

      setTimeout(() => {
        setShowNotification(false);
        setScanned(false);
      }, 2000);
    }
  };

  const handleBarCodeScanned = async ({
    type,
    data,
  }: {
    type: string;
    data: string;
  }) => {
    // Use refs for immediate check (prevent race conditions)
    const now = Date.now();
    const timeSinceLastScan = now - lastScanTimeRef.current;

    // Check if already processing
    if (isProcessingRef.current) {
      console.log('‚è≥ Already processing a scan, ignoring...');
      return;
    }

    // Check cooldown period
    if (timeSinceLastScan < SCAN_COOLDOWN) {
      console.log(
        `‚è±Ô∏è Cooldown active: ${Math.ceil(
          (SCAN_COOLDOWN - timeSinceLastScan) / 1000
        )}s remaining`
      );
      return;
    }

    // Check if same QR code
    if (lastScanDataRef.current === data && timeSinceLastScan < 10000) {
      console.log('üîÑ Same QR code scanned within 10 seconds, ignoring...');
      return;
    }

    // Mark as processing immediately
    isProcessingRef.current = true;
    lastScanTimeRef.current = now;
    lastScanDataRef.current = data;

    setScanned(true);
    setProcessing(true);

    console.log('‚úÖ QR Scan started:', {
      data: data.substring(0, 30) + '...',
      timestamp: new Date().toISOString(),
    });

    try {
      // Validate the scanned data
      if (!data || typeof data !== 'string' || data.trim().length === 0) {
        setNotificationType('error');
        setNotificationData(null);
        setShowNotification(true);
        setProcessing(false);
        isProcessingRef.current = false;
        setTimeout(() => {
          setShowNotification(false);
          setScanned(false);
        }, 2000);
        return;
      }

      // Check if user is logged in
      if (!user?.id) {
        setNotificationType('error');
        setNotificationData(null);
        setShowNotification(true);
        setProcessing(false);
        isProcessingRef.current = false;
        setTimeout(() => {
          setShowNotification(false);
          setScanned(false);
        }, 2000);
        return;
      }

      // Check if QR code starts with GYM_ACCESS
      if (!data.trim().startsWith('GYM_ACCESS')) {
        setNotificationType('error');
        setNotificationData(null);
        setShowNotification(true);
        setProcessing(false);
        isProcessingRef.current = false;
        setTimeout(() => {
          setShowNotification(false);
          setScanned(false);
        }, 2000);
        return;
      }

      // Extract location from QR code
      const qrLocation = data.includes('MAIN')
        ? 'Main Entrance'
        : data.includes('SIDE')
        ? 'Side Gate'
        : data.includes('VIP')
        ? 'VIP Entrance'
        : data.includes('STAFF')
        ? 'Staff Entry'
        : data.includes('EMERGENCY')
        ? 'Emergency Exit'
        : 'Main Entrance';

      setScannedQRLocation(qrLocation);

      // Check if user already has active session
      if (!member?.id) {
        console.error('Member ID not available');
        return;
      }
      const currentSession = await accessService.getCurrentAccess(member.id);

      console.log('üìä Current session check:', {
        success: currentSession.success,
        hasData: !!currentSession.data,
        session: currentSession.data?.session,
      });

      // Backend returns { data: { session } }, so check for session property
      const hasActiveSession =
        currentSession.success && currentSession.data?.session;

      if (hasActiveSession) {
        // Already checked in - Show rating modal first
        console.log('üö™ Preparing CHECK OUT with rating...');
        const session = currentSession.data?.session;

        // Calculate duration
        const entryTime = new Date(session.entry_time).getTime();
        const now = Date.now();
        const durationMinutes = Math.floor((now - entryTime) / (1000 * 60));

        // Don't estimate calories - backend will calculate from equipment usage
        // Show 0 in modal as placeholder (it says "estimated, will be recalculated")

        setSessionData({
          session,
          duration: durationMinutes,
          calories: 0, // Backend will calculate from equipment usage
        });

        setProcessing(false);
        isProcessingRef.current = false;
        setShowRatingModal(true);
      } else {
        // No active session - perform CHECK IN
        if (!member?.id) {
          console.error('Member ID not available');
          return;
        }
        console.log('üèãÔ∏è Performing CHECK IN...');
        const checkInResponse = await accessService.checkIn({
          memberId: member.id,
          method: 'QR_CODE',
          data: data.trim(),
          location: qrLocation,
        });

        if (checkInResponse.success) {
          // Show check-in notification
          setNotificationType('check-in');
          setNotificationData({
            location: qrLocation,
            time: new Date().toLocaleTimeString(),
          });
          setShowNotification(true);
          setProcessing(false);
          isProcessingRef.current = false;

          // Auto navigate to home after 3 seconds
          navigationTimeoutRef.current = setTimeout(() => {
            setShowNotification(false);
            router.push('/(tabs)');
          }, 3000);
        } else {
          setNotificationType('error');
          setNotificationData(null);
          setShowNotification(true);
          setProcessing(false);
          isProcessingRef.current = false;

          setTimeout(() => {
            setShowNotification(false);
            setScanned(false);
          }, 2000);
        }
      }
    } catch (error: any) {
      console.error('QR scan error:', error);
      setNotificationType('error');
      setNotificationData(null);
      setShowNotification(true);
      setProcessing(false);
      isProcessingRef.current = false;

      setTimeout(() => {
        setShowNotification(false);
        setScanned(false);
      }, 2000);
    }
  };

  const resetScanner = () => {
    setScanned(false);
    setProcessing(false);
    isProcessingRef.current = false;
    lastScanTimeRef.current = 0;
    lastScanDataRef.current = '';
  };

  if (!permission) {
    return (
      <SafeAreaView
        style={[styles.container, { backgroundColor: theme.colors.background }]}
      >
        <View style={styles.permissionContainer}>
          <Text style={[styles.permissionText, { color: theme.colors.text }]}>
            Requesting camera permission...
          </Text>
        </View>
      </SafeAreaView>
    );
  }

  if (!permission.granted) {
    return (
      <SafeAreaView
        style={[styles.container, { backgroundColor: theme.colors.background }]}
      >
        <View style={styles.permissionContainer}>
          <Text style={[styles.permissionText, { color: theme.colors.text }]}>
            Camera permission is required to scan QR codes
          </Text>
          <TouchableOpacity
            style={[
              styles.permissionButton,
              { backgroundColor: theme.colors.primary },
            ]}
            onPress={requestPermission}
          >
            <Text
              style={[
                styles.permissionButtonText,
                { color: theme.colors.textInverse },
              ]}
            >
              Grant Permission
            </Text>
          </TouchableOpacity>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.colors.background }]}
    >
      {/* Header */}
      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => router.back()}
        >
          <ArrowLeft size={24} color={theme.colors.textInverse} />
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: theme.colors.textInverse }]}>
          QR Code Scanner
        </Text>
        <View style={styles.headerSpacer} />
      </View>

      {/* Camera View */}
      <View style={styles.cameraContainer}>
        <CameraView
          style={styles.camera}
          facing="back"
          onBarcodeScanned={scanned ? undefined : handleBarCodeScanned}
          barcodeScannerSettings={{
            barcodeTypes: ['qr'],
          }}
        >
          {/* Overlay */}
          <View style={styles.overlay}>
            {/* Top overlay */}
            <View
              style={[
                styles.overlaySection,
                { backgroundColor: 'rgba(0,0,0,0.5)' },
              ]}
            />

            {/* Middle section with scanning area */}
            <View style={styles.middleSection}>
              <View
                style={[
                  styles.overlaySection,
                  { backgroundColor: 'rgba(0,0,0,0.5)' },
                ]}
              />

              <View style={styles.scanArea}>
                <View
                  style={[
                    styles.scanFrame,
                    { borderColor: theme.colors.primary },
                  ]}
                >
                  <View
                    style={[
                      styles.corner,
                      styles.topLeft,
                      { borderColor: theme.colors.primary },
                    ]}
                  />
                  <View
                    style={[
                      styles.corner,
                      styles.topRight,
                      { borderColor: theme.colors.primary },
                    ]}
                  />
                  <View
                    style={[
                      styles.corner,
                      styles.bottomLeft,
                      { borderColor: theme.colors.primary },
                    ]}
                  />
                  <View
                    style={[
                      styles.corner,
                      styles.bottomRight,
                      { borderColor: theme.colors.primary },
                    ]}
                  />
                </View>
              </View>

              <View
                style={[
                  styles.overlaySection,
                  { backgroundColor: 'rgba(0,0,0,0.5)' },
                ]}
              />
            </View>

            {/* Bottom overlay */}
            <View
              style={[
                styles.overlaySection,
                { backgroundColor: 'rgba(0,0,0,0.5)' },
              ]}
            />
          </View>

          {/* Instructions */}
          <View style={styles.instructionsContainer}>
            <Text
              style={[
                styles.instructionsText,
                { color: theme.colors.textInverse },
              ]}
            >
              Position the QR code within the frame
            </Text>
          </View>
        </CameraView>
      </View>

      {/* Processing Overlay */}
      {processing && (
        <View
          style={[
            styles.processingOverlay,
            { backgroundColor: 'rgba(0,0,0,0.8)' },
          ]}
        >
          <View
            style={[
              styles.processingContainer,
              { backgroundColor: theme.colors.surface },
            ]}
          >
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={[styles.processingText, { color: theme.colors.text }]}>
              {t('common.processing', 'Processing...')}
            </Text>
          </View>
        </View>
      )}

      {/* Notification Modal */}
      <AccessNotificationModal
        visible={showNotification}
        type={notificationType}
        onClose={() => {
          // Not used - auto-navigate via timeout
        }}
        data={notificationData}
      />

      {/* Rating Modal */}
      <SessionRatingModal
        visible={showRatingModal}
        onClose={() => setShowRatingModal(false)}
        onSubmit={handleRatingSubmit}
        sessionData={
          sessionData
            ? {
                duration: sessionData.duration,
                calories: sessionData.calories,
              }
            : undefined
        }
      />
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    zIndex: 10,
  },
  backButton: {
    padding: 8,
    borderRadius: 20,
    backgroundColor: 'rgba(0,0,0,0.5)',
  },
  headerTitle: {
    ...Typography.h3,
    flex: 1,
    textAlign: 'center',
    marginHorizontal: 16,
  },
  headerSpacer: {
    width: 40,
  },
  cameraContainer: {
    flex: 1,
  },
  camera: {
    flex: 1,
  },
  overlay: {
    flex: 1,
  },
  overlaySection: {
    flex: 1,
  },
  middleSection: {
    flexDirection: 'row',
    height: 200,
  },
  scanArea: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  scanFrame: {
    width: 250,
    height: 250,
    borderWidth: 2,
    position: 'relative',
  },
  corner: {
    position: 'absolute',
    width: 30,
    height: 30,
    borderWidth: 3,
  },
  topLeft: {
    top: -3,
    left: -3,
    borderRightWidth: 0,
    borderBottomWidth: 0,
  },
  topRight: {
    top: -3,
    right: -3,
    borderLeftWidth: 0,
    borderBottomWidth: 0,
  },
  bottomLeft: {
    bottom: -3,
    left: -3,
    borderRightWidth: 0,
    borderTopWidth: 0,
  },
  bottomRight: {
    bottom: -3,
    right: -3,
    borderLeftWidth: 0,
    borderTopWidth: 0,
  },
  instructionsContainer: {
    position: 'absolute',
    bottom: 100,
    left: 0,
    right: 0,
    alignItems: 'center',
  },
  instructionsText: {
    ...Typography.bodyMedium,
    textAlign: 'center',
    backgroundColor: 'rgba(0,0,0,0.7)',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 20,
  },
  resultOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'center',
  },
  resultContainer: {
    padding: 32,
    borderRadius: 16,
    alignItems: 'center',
    marginHorizontal: 32,
  },
  resultText: {
    ...Typography.bodyMedium,
    textAlign: 'center',
    marginTop: 16,
    marginBottom: 24,
  },
  retryButton: {
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
  },
  retryButtonText: {
    ...Typography.bodyMedium,
    fontWeight: '600',
  },
  processingOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'center',
  },
  processingContainer: {
    padding: 32,
    borderRadius: 16,
    alignItems: 'center',
    marginHorizontal: 32,
  },
  processingText: {
    ...Typography.bodyMedium,
    textAlign: 'center',
    marginTop: 16,
  },
  permissionContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 32,
  },
  permissionText: {
    ...Typography.bodyMedium,
    textAlign: 'center',
    marginBottom: 24,
  },
  permissionButton: {
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
  },
  permissionButtonText: {
    ...Typography.bodyMedium,
    fontWeight: '600',
  },
});
