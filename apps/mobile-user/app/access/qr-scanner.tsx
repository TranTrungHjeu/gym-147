import AccessNotificationModal from '@/components/AccessNotificationModal';
import SessionRatingModal from '@/components/SessionRatingModal';
import ClassRatingModal from '@/components/ClassRatingModal';
import { useAuth } from '@/contexts/AuthContext';
import { accessService } from '@/services/member/access.service';
import { attendanceService } from '@/services/schedule/attendance.service';
import { useTheme } from '@/utils/theme';
import { Typography } from '@/utils/typography';
import { CameraView, useCameraPermissions } from 'expo-camera';
import { useRouter } from 'expo-router';
import { ArrowLeft } from 'lucide-react-native';
import React, { useEffect, useRef, useState } from 'react';
import { useTranslation } from 'react-i18next';
import {
  ActivityIndicator,
  Alert,
  Modal,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';
import { SafeAreaView, useSafeAreaInsets } from 'react-native-safe-area-context';

export default function QRScannerScreen() {
  const { t } = useTranslation();
  const { theme } = useTheme();
  const { user, member } = useAuth();
  const router = useRouter();
  const insets = useSafeAreaInsets();

  const [permission, requestPermission] = useCameraPermissions();
  const [scanned, setScanned] = useState(false);
  const [processing, setProcessing] = useState(false);
  const [showRatingModal, setShowRatingModal] = useState(false);
  const [sessionData, setSessionData] = useState<any>(null);
  const [scannedQRLocation, setScannedQRLocation] =
    useState<string>('Main Entrance');

  // Class rating modal state
  const [showClassRatingModal, setShowClassRatingModal] = useState(false);
  const [classRatingData, setClassRatingData] = useState<{
    scheduleId?: string;
    className?: string;
    trainerName?: string;
    attendanceId?: string;
  } | null>(null);

  // Notification modal state
  const [showNotification, setShowNotification] = useState(false);
  const [notificationType, setNotificationType] = useState<
    'check-in' | 'check-out' | 'error'
  >('check-in');
  const [notificationData, setNotificationData] = useState<any>(null);

  // Early checkout modal state
  const [showEarlyCheckoutModal, setShowEarlyCheckoutModal] = useState(false);
  const [earlyCheckoutMessage, setEarlyCheckoutMessage] = useState<string>('');

  // Refs for immediate tracking (prevent race conditions)
  const isProcessingRef = useRef(false);
  const lastScanTimeRef = useRef(0);
  const lastScanDataRef = useRef('');
  const navigationTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const SCAN_COOLDOWN = 3000; // 3 seconds minimum between scans

  useEffect(() => {
    if (!permission?.granted) {
      requestPermission();
    }
  }, [permission]);

  // Reset refs when screen is focused
  useEffect(() => {
    return () => {
      // Cleanup on unmount
      isProcessingRef.current = false;
      lastScanTimeRef.current = 0;
      lastScanDataRef.current = '';
      if (navigationTimeoutRef.current) {
        clearTimeout(navigationTimeoutRef.current);
      }
    };
  }, []);

  // Auto-generate notes based on calories and body metrics
  // Notes are now generated by backend with accurate calories calculation
  // const generateSessionNotes = ... (removed, backend handles this)

  const handleRatingSubmit = async (rating: number) => {
    if (!user?.id || !sessionData) return;

    try {
      console.log('[PROCESS] Submitting rating:', rating);

      // Backend will generate accurate notes based on final calculated calories
      // Don't send notes from mobile app to avoid inconsistency

      // Perform CHECK OUT with rating (backend will generate notes)
      if (!member?.id) {
        console.error('Member ID not available');
        return;
      }
      const checkOutResponse = await accessService.checkOut({
        memberId: member.id,
        location: scannedQRLocation,
        session_rating: rating,
        // notes: undefined - let backend generate with accurate calories
        exit_method: 'QR_CODE', // Pass exit method
      });

      if (checkOutResponse.success) {
        setShowRatingModal(false);

        // Use accurate calories from backend response (calculated from equipment usage)
        const accurateCalories =
          checkOutResponse.data?.session?.calories_burned ||
          sessionData.calories;

        console.log('[CALORIES] Calories comparison:', {
          fromSession: sessionData.calories,
          fromBackend: checkOutResponse.data?.session?.calories_burned,
          usingAccurate: accurateCalories,
        });

        // Show check-out notification with accurate data
        setNotificationType('check-out');
        setNotificationData({
          location: scannedQRLocation,
          time: new Date().toLocaleTimeString(),
          duration: sessionData.duration,
          calories: accurateCalories, // [SUCCESS] Use backend's accurate calories
        });
        setShowNotification(true);
        setProcessing(false);
        isProcessingRef.current = false;

        // Auto navigate to home after 3 seconds
        navigationTimeoutRef.current = setTimeout(() => {
          setShowNotification(false);
          router.push('/(tabs)');
        }, 3000);
      } else {
        setShowRatingModal(false);
        setNotificationType('error');
        setNotificationData(null);
        setShowNotification(true);
        setProcessing(false);
        isProcessingRef.current = false;

        setTimeout(() => {
          setShowNotification(false);
          setScanned(false);
        }, 2000);
      }
    } catch (error: any) {
      console.error('Rating submit error:', error);
      setShowRatingModal(false);
      setNotificationType('error');
      setNotificationData(null);
      setShowNotification(true);
      setProcessing(false);
      isProcessingRef.current = false;

      setTimeout(() => {
        setShowNotification(false);
        setScanned(false);
      }, 2000);
    }
  };

  const handleBarCodeScanned = async ({
    type,
    data,
  }: {
    type: string;
    data: string;
  }) => {
    // Use refs for immediate check (prevent race conditions)
    const now = Date.now();
    const timeSinceLastScan = now - lastScanTimeRef.current;

    // Check if already processing
    if (isProcessingRef.current) {
      console.log('[PROCESS] Already processing a scan, ignoring...');
      return;
    }

    // Check cooldown period
    if (timeSinceLastScan < SCAN_COOLDOWN) {
      console.log(
        `[TIMER] Cooldown active: ${Math.ceil(
          (SCAN_COOLDOWN - timeSinceLastScan) / 1000
        )}s remaining`
      );
      return;
    }

    // Check if same QR code
    if (lastScanDataRef.current === data && timeSinceLastScan < 10000) {
      console.log('[RESET] Same QR code scanned within 10 seconds, ignoring...');
      return;
    }

    // Mark as processing immediately
    isProcessingRef.current = true;
    lastScanTimeRef.current = now;
    lastScanDataRef.current = data;

    setScanned(true);
    setProcessing(true);

    console.log('[SUCCESS] QR Scan started:', {
      data: data.substring(0, 30) + '...',
      timestamp: new Date().toISOString(),
    });

    try {
      // Validate the scanned data
      if (!data || typeof data !== 'string' || data.trim().length === 0) {
        setNotificationType('error');
        setNotificationData(null);
        setShowNotification(true);
        setProcessing(false);
        isProcessingRef.current = false;
        setTimeout(() => {
          setShowNotification(false);
          setScanned(false);
        }, 2000);
        return;
      }

      // Check if user is logged in
      if (!user?.id) {
        setNotificationType('error');
        setNotificationData(null);
        setShowNotification(true);
        setProcessing(false);
        isProcessingRef.current = false;
        setTimeout(() => {
          setShowNotification(false);
          setScanned(false);
        }, 2000);
        return;
      }

      // Check QR code type
      const qrData = data.trim();
      
      // Handle SCHEDULE_QR for class check-in/check-out
      if (qrData.startsWith('SCHEDULE_QR')) {
        if (!member?.id) {
          setNotificationType('error');
          setNotificationData(null);
          setShowNotification(true);
          setProcessing(false);
          isProcessingRef.current = false;
          setTimeout(() => {
            setShowNotification(false);
            setScanned(false);
          }, 2000);
          return;
        }

        console.log('[SCHEDULE_QR] Processing schedule QR code...');
        const result = await attendanceService.scanQRCodeCheckInOut(qrData, member.id);

        if (result.success && result.data) {
          const isCheckIn = !!result.data.check_in_time;
          const isCheckOut = !!result.data.check_out_time;

          // If check-out successful, show rating modal
          if (isCheckOut && result.data.attendance) {
            const attendance = result.data.attendance;
            const schedule = attendance.schedule;
            
            setClassRatingData({
              scheduleId: schedule?.id,
              className: schedule?.gym_class?.name || 'L·ªõp h·ªçc',
              trainerName: schedule?.trainer?.full_name || 'Hu·∫•n luy·ªán vi√™n',
              attendanceId: attendance.id,
            });
            setShowClassRatingModal(true);
            setProcessing(false);
            isProcessingRef.current = false;
            setScanned(false);
            return;
          }

          // For check-in, show notification
          setNotificationType('success');
          setNotificationData({
            title: isCheckIn ? t('attendance.checkInSuccess') : t('attendance.checkOutSuccess'),
            message: isCheckIn
              ? t('attendance.checkInSuccessMessage')
              : t('attendance.checkOutSuccessMessage'),
          });
          setShowNotification(true);
          setProcessing(false);
          isProcessingRef.current = false;

          // Auto navigate after 2 seconds
          setTimeout(() => {
            setShowNotification(false);
            setScanned(false);
            router.push('/(tabs)/classes');
          }, 2000);
        } else {
          // Check if it's an early checkout error
          const errorMessage = result.error || t('attendance.checkInOutErrorMessage');
          const isEarlyCheckoutError =
            errorMessage.includes('not available at this time') ||
            errorMessage.includes('Check-out is not available') ||
            errorMessage.includes('kh√¥ng kh·∫£ d·ª•ng');

          if (isEarlyCheckoutError) {
            // Show modal for early checkout error (no error notification below)
            setEarlyCheckoutMessage(errorMessage);
            setShowEarlyCheckoutModal(true);
            setProcessing(false);
            isProcessingRef.current = false;
            setScanned(false);
          } else {
            // For other errors, just log and reset (no error notification)
            console.error('[ATTENDANCE] Check-in/check-out error:', errorMessage);
            setProcessing(false);
            isProcessingRef.current = false;
            setScanned(false);
          }
        }
        return;
      }

      // Handle GYM_ACCESS for gym entry/exit
      if (!qrData.startsWith('GYM_ACCESS')) {
        setNotificationType('error');
        setNotificationData(null);
        setShowNotification(true);
        setProcessing(false);
        isProcessingRef.current = false;
        setTimeout(() => {
          setShowNotification(false);
          setScanned(false);
        }, 2000);
        return;
      }

      // Extract location from QR code
      const qrLocation = data.includes('MAIN')
        ? 'Main Entrance'
        : data.includes('SIDE')
        ? 'Side Gate'
        : data.includes('VIP')
        ? 'VIP Entrance'
        : data.includes('STAFF')
        ? 'Staff Entry'
        : data.includes('EMERGENCY')
        ? 'Emergency Exit'
        : 'Main Entrance';

      setScannedQRLocation(qrLocation);

      // Check if user already has active session
      if (!member?.id) {
        console.error('Member ID not available');
        return;
      }
      const currentSession = await accessService.getCurrentAccess(member.id);

      console.log('[DATA] Current session check:', {
        success: currentSession.success,
        hasData: !!currentSession.data,
        session: currentSession.data?.session,
      });

      // Backend returns { data: { session } }, so check for session property
      const hasActiveSession =
        currentSession.success && currentSession.data?.session;

      if (hasActiveSession) {
        // Already checked in - Show rating modal first
        console.log('üö™ Preparing CHECK OUT with rating...');
        const session = currentSession.data?.session;

        // Calculate duration
        const entryTime = new Date(session.entry_time).getTime();
        const now = Date.now();
        const durationMinutes = Math.floor((now - entryTime) / (1000 * 60));

        // Don't estimate calories - backend will calculate from equipment usage
        // Show 0 in modal as placeholder (it says "estimated, will be recalculated")

        setSessionData({
          session,
          duration: durationMinutes,
          calories: 0, // Backend will calculate from equipment usage
        });

        setProcessing(false);
        isProcessingRef.current = false;
        setShowRatingModal(true);
      } else {
        // No active session - perform CHECK IN
        if (!member?.id) {
          console.error('Member ID not available');
          return;
        }
        console.log('[EQUIPMENT] Performing CHECK IN...');
        const checkInResponse = await accessService.checkIn({
          memberId: member.id,
          method: 'QR_CODE',
          data: data.trim(),
          location: qrLocation,
        });

        if (checkInResponse.success) {
          // Show check-in notification
          setNotificationType('check-in');
          setNotificationData({
            location: qrLocation,
            time: new Date().toLocaleTimeString(),
          });
          setShowNotification(true);
          setProcessing(false);
          isProcessingRef.current = false;

          // Auto navigate to home after 3 seconds
          navigationTimeoutRef.current = setTimeout(() => {
            setShowNotification(false);
            router.push('/(tabs)');
          }, 3000);
        } else {
          setNotificationType('error');
          setNotificationData(null);
          setShowNotification(true);
          setProcessing(false);
          isProcessingRef.current = false;

          setTimeout(() => {
            setShowNotification(false);
            setScanned(false);
          }, 2000);
        }
      }
    } catch (error: any) {
      console.error('QR scan error:', error);
      setNotificationType('error');
      setNotificationData(null);
      setShowNotification(true);
      setProcessing(false);
      isProcessingRef.current = false;

      setTimeout(() => {
        setShowNotification(false);
        setScanned(false);
      }, 2000);
    }
  };

  const resetScanner = () => {
    setScanned(false);
    setProcessing(false);
    isProcessingRef.current = false;
    lastScanTimeRef.current = 0;
    lastScanDataRef.current = '';
  };

  if (!permission) {
    return (
      <SafeAreaView
        style={[styles.container, { backgroundColor: theme.colors.background }]}
        edges={['top', 'bottom']}
      >
        <View style={styles.permissionContainer}>
          <Text style={[styles.permissionText, { color: theme.colors.text }]}>
            Requesting camera permission...
          </Text>
        </View>
      </SafeAreaView>
    );
  }

  if (!permission.granted) {
    return (
      <SafeAreaView
        style={[styles.container, { backgroundColor: theme.colors.background }]}
        edges={['top', 'bottom']}
      >
        <View style={styles.permissionContainer}>
          <Text style={[styles.permissionText, { color: theme.colors.text }]}>
            Camera permission is required to scan QR codes
          </Text>
          <TouchableOpacity
            style={[
              styles.permissionButton,
              { backgroundColor: theme.colors.primary },
            ]}
            onPress={requestPermission}
          >
            <Text
              style={[
                styles.permissionButtonText,
                { color: theme.colors.textInverse },
              ]}
            >
              Grant Permission
            </Text>
          </TouchableOpacity>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.colors.background }]}
      edges={['top']}
    >
      {/* Header */}
      <View style={[styles.header, { paddingTop: insets.top + 12 }]}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => router.back()}
        >
          <ArrowLeft size={24} color={theme.colors.textInverse} />
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: theme.colors.textInverse }]}>
          QR Code Scanner
        </Text>
        <View style={styles.headerSpacer} />
      </View>

      {/* Camera View */}
      <View style={styles.cameraContainer}>
        <CameraView
          style={styles.camera}
          facing="back"
          onBarcodeScanned={scanned ? undefined : handleBarCodeScanned}
          barcodeScannerSettings={{
            barcodeTypes: ['qr'],
          }}
        >
          {/* Overlay */}
          <View style={styles.overlay}>
            {/* Top overlay */}
            <View
              style={[
                styles.overlaySection,
                { backgroundColor: 'rgba(0,0,0,0.5)' },
              ]}
            />

            {/* Middle section with scanning area */}
            <View style={styles.middleSection}>
              <View
                style={[
                  styles.overlaySection,
                  { backgroundColor: 'rgba(0,0,0,0.5)' },
                ]}
              />

              <View style={styles.scanArea}>
                <View
                  style={[
                    styles.scanFrame,
                    { borderColor: theme.colors.primary },
                  ]}
                >
                  <View
                    style={[
                      styles.corner,
                      styles.topLeft,
                      { borderColor: theme.colors.primary },
                    ]}
                  />
                  <View
                    style={[
                      styles.corner,
                      styles.topRight,
                      { borderColor: theme.colors.primary },
                    ]}
                  />
                  <View
                    style={[
                      styles.corner,
                      styles.bottomLeft,
                      { borderColor: theme.colors.primary },
                    ]}
                  />
                  <View
                    style={[
                      styles.corner,
                      styles.bottomRight,
                      { borderColor: theme.colors.primary },
                    ]}
                  />
                </View>
              </View>

              <View
                style={[
                  styles.overlaySection,
                  { backgroundColor: 'rgba(0,0,0,0.5)' },
                ]}
              />
            </View>

            {/* Bottom overlay */}
            <View
              style={[
                styles.overlaySection,
                { backgroundColor: 'rgba(0,0,0,0.5)' },
              ]}
            />
          </View>

          {/* Instructions */}
          <View style={styles.instructionsContainer}>
            <Text
              style={[
                styles.instructionsText,
                { color: theme.colors.textInverse },
              ]}
            >
              Position the QR code within the frame
            </Text>
          </View>
        </CameraView>
      </View>

      {/* Processing Overlay */}
      {processing && (
        <View
          style={[
            styles.processingOverlay,
            { backgroundColor: 'rgba(0,0,0,0.8)' },
          ]}
        >
          <View
            style={[
              styles.processingContainer,
              { backgroundColor: theme.colors.surface },
            ]}
          >
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={[styles.processingText, { color: theme.colors.text }]}>
              {t('common.processing', 'Processing...')}
            </Text>
          </View>
        </View>
      )}

      {/* Notification Modal */}
      <AccessNotificationModal
        visible={showNotification}
        type={notificationType}
        onClose={() => {
          // Not used - auto-navigate via timeout
        }}
        data={notificationData}
      />

      {/* Early Checkout Modal */}
      <Modal
        visible={showEarlyCheckoutModal}
        transparent
        animationType="fade"
        onRequestClose={() => setShowEarlyCheckoutModal(false)}
      >
        <View
          style={[
            styles.modalOverlay,
            { backgroundColor: 'rgba(0, 0, 0, 0.6)' },
          ]}
        >
          <View
            style={[
              styles.modalContainer,
              {
                backgroundColor: theme.colors.surface,
                borderRadius: 24,
                padding: 24,
              },
            ]}
          >
            <View style={styles.modalHeader}>
              <Text
                style={[
                  Typography.h3,
                  { color: theme.colors.text, flex: 1 },
                ]}
              >
                {t('attendance.checkInOutError') || 'Kh√¥ng th·ªÉ check-out'}
              </Text>
              <TouchableOpacity
                onPress={() => setShowEarlyCheckoutModal(false)}
                style={[
                  styles.closeButton,
                  { backgroundColor: theme.colors.surface },
                ]}
              >
                <Text style={[Typography.bodyMedium, { color: theme.colors.text }]}>‚úï</Text>
              </TouchableOpacity>
            </View>

            <View
              style={[
                styles.iconContainer,
                { backgroundColor: `${theme.colors.warning || theme.colors.error}15` },
              ]}
            >
              <Text style={{ fontSize: 48 }}>‚ö†Ô∏è</Text>
            </View>

            <Text
              style={[
                Typography.body,
                {
                  color: theme.colors.text,
                  textAlign: 'center',
                  marginBottom: 24,
                },
              ]}
            >
              {earlyCheckoutMessage ||
                t('attendance.earlyCheckoutMessage') ||
                'B·∫°n kh√¥ng th·ªÉ check-out qu√° s·ªõm. Vui l√≤ng ƒë·ª£i ƒë·∫øn khi l·ªõp h·ªçc k·∫øt th√∫c ho·∫∑c trong v√≤ng 10 ph√∫t sau khi l·ªõp k·∫øt th√∫c.'}
            </Text>

            <TouchableOpacity
              style={[
                styles.modalButton,
                {
                  backgroundColor: theme.colors.primary,
                  paddingVertical: 16,
                  borderRadius: 12,
                },
              ]}
              onPress={() => {
                setShowEarlyCheckoutModal(false);
                setScanned(false);
              }}
            >
              <Text
                style={[
                  Typography.bodyMedium,
                  {
                    color: theme.colors.textInverse,
                    fontWeight: '600',
                    textAlign: 'center',
                  },
                ]}
              >
                {t('common.ok') || 'ƒê√£ hi·ªÉu'}
              </Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Session Rating Modal (for gym session) */}
      <SessionRatingModal
        visible={showRatingModal}
        onClose={() => setShowRatingModal(false)}
        onSubmit={handleRatingSubmit}
        sessionData={
          sessionData
            ? {
                duration: sessionData.duration,
                calories: sessionData.calories,
              }
            : undefined
        }
      />

      {/* Class Rating Modal (for class check-out) */}
      <ClassRatingModal
        visible={showClassRatingModal}
        onClose={() => {
          setShowClassRatingModal(false);
          setClassRatingData(null);
          // Navigate to classes tab after closing
          setTimeout(() => {
            router.push('/(tabs)/classes');
          }, 300);
        }}
        onSubmit={async (rating) => {
          if (!classRatingData?.scheduleId || !member?.id) {
            return;
          }

          try {
            const result = await attendanceService.submitRating(
              classRatingData.scheduleId,
              member.id,
              rating
            );

            if (result.success) {
              setShowClassRatingModal(false);
              setClassRatingData(null);
              
              // Show success notification
              setNotificationType('success');
              setNotificationData({
                title: t('classes.rating.submitSuccess', 'C·∫£m ∆°n b·∫°n ƒë√£ ƒë√°nh gi√°!'),
                message: t('classes.rating.submitSuccessMessage', 'ƒê√°nh gi√° c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c ghi nh·∫≠n.'),
              });
              setShowNotification(true);

              // Navigate to classes tab after 2 seconds
              setTimeout(() => {
                setShowNotification(false);
                router.push('/(tabs)/classes');
              }, 2000);
            } else {
              Alert.alert(
                t('common.error'),
                result.error || t('classes.rating.submitError', 'Kh√¥ng th·ªÉ g·ª≠i ƒë√°nh gi√°')
              );
            }
          } catch (error: any) {
            console.error('[ERROR] Submit class rating error:', error);
            Alert.alert(
              t('common.error'),
              error.message || t('classes.rating.submitError', 'Kh√¥ng th·ªÉ g·ª≠i ƒë√°nh gi√°')
            );
          }
        }}
        className={classRatingData?.className}
        trainerName={classRatingData?.trainerName}
      />
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingTop: 12,
    paddingBottom: 12,
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    zIndex: 10,
  },
  backButton: {
    padding: 8,
    borderRadius: 20,
    backgroundColor: 'rgba(0,0,0,0.5)',
  },
  headerTitle: {
    ...Typography.h3,
    flex: 1,
    textAlign: 'center',
    marginHorizontal: 16,
  },
  headerSpacer: {
    width: 40,
  },
  cameraContainer: {
    flex: 1,
  },
  camera: {
    flex: 1,
  },
  overlay: {
    flex: 1,
  },
  overlaySection: {
    flex: 1,
  },
  middleSection: {
    flexDirection: 'row',
    height: 200,
  },
  scanArea: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  scanFrame: {
    width: 250,
    height: 250,
    borderWidth: 2,
    position: 'relative',
  },
  corner: {
    position: 'absolute',
    width: 30,
    height: 30,
    borderWidth: 3,
  },
  topLeft: {
    top: -3,
    left: -3,
    borderRightWidth: 0,
    borderBottomWidth: 0,
  },
  topRight: {
    top: -3,
    right: -3,
    borderLeftWidth: 0,
    borderBottomWidth: 0,
  },
  bottomLeft: {
    bottom: -3,
    left: -3,
    borderRightWidth: 0,
    borderTopWidth: 0,
  },
  bottomRight: {
    bottom: -3,
    right: -3,
    borderLeftWidth: 0,
    borderTopWidth: 0,
  },
  instructionsContainer: {
    position: 'absolute',
    bottom: 100,
    left: 0,
    right: 0,
    alignItems: 'center',
  },
  instructionsText: {
    ...Typography.bodyMedium,
    textAlign: 'center',
    backgroundColor: 'rgba(0,0,0,0.7)',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 20,
  },
  resultOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'center',
  },
  resultContainer: {
    padding: 32,
    borderRadius: 16,
    alignItems: 'center',
    marginHorizontal: 32,
  },
  resultText: {
    ...Typography.bodyMedium,
    textAlign: 'center',
    marginTop: 16,
    marginBottom: 24,
  },
  retryButton: {
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
  },
  retryButtonText: {
    ...Typography.bodyMedium,
    fontWeight: '600',
  },
  processingOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'center',
  },
  processingContainer: {
    padding: 32,
    borderRadius: 16,
    alignItems: 'center',
    marginHorizontal: 32,
  },
  processingText: {
    ...Typography.bodyMedium,
    textAlign: 'center',
    marginTop: 16,
  },
  permissionContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 32,
  },
  permissionText: {
    ...Typography.bodyMedium,
    textAlign: 'center',
    marginBottom: 24,
  },
  permissionButton: {
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
  },
  permissionButtonText: {
    ...Typography.bodyMedium,
    fontWeight: '600',
  },
  modalOverlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  modalContainer: {
    width: '100%',
    maxWidth: 400,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 20 },
    shadowOpacity: 0.3,
    shadowRadius: 30,
    elevation: 15,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  closeButton: {
    width: 32,
    height: 32,
    borderRadius: 16,
    justifyContent: 'center',
    alignItems: 'center',
  },
  iconContainer: {
    width: 80,
    height: 80,
    borderRadius: 40,
    justifyContent: 'center',
    alignItems: 'center',
    alignSelf: 'center',
    marginBottom: 20,
  },
  modalButton: {
    alignItems: 'center',
  },
});
